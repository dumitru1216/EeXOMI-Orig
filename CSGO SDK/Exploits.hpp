#pragma once

class bf_read {
public:
  const char* m_pDebugName;
  bool m_bOverflow;
  int m_nDataBits;
  unsigned int m_nDataBytes;
  unsigned int m_nInBufWord;
  int m_nBitsAvail;
  const unsigned int* m_pDataIn;
  const unsigned int* m_pBufferEnd;
  const unsigned int* m_pData;

  bf_read( ) = default;

  bf_read( const void* pData, int nBytes, int nBits = -1 ) {
	 StartReading( pData, nBytes, 0, nBits );
  }

  void StartReading( const void* pData, int nBytes, int iStartBit, int nBits ) {
	 // Make sure it's dword aligned and padded.
	 m_pData = ( uint32_t* )pData;
	 m_pDataIn = m_pData;
	 m_nDataBytes = nBytes;

	 if( nBits == -1 ) {
		m_nDataBits = nBytes << 3;
	 } else {
		m_nDataBits = nBits;
	 }
	 m_bOverflow = false;
	 m_pBufferEnd = reinterpret_cast< uint32_t const* >( reinterpret_cast< uint8_t const* >( m_pData ) + nBytes );
	 if( m_pData )
		Seek( iStartBit );
  }

  bool Seek( int nPosition ) {
	 bool bSucc = true;
	 if( nPosition < 0 || nPosition > m_nDataBits ) {
		m_bOverflow = true;
		bSucc = false;
		nPosition = m_nDataBits;
	 }
	 int nHead = m_nDataBytes & 3; // non-multiple-of-4 bytes at head of buffer. We put the "round off"
											 // at the head to make reading and detecting the end efficient.

	 int nByteOfs = nPosition / 8;
	 if( ( m_nDataBytes < 4 ) || ( nHead && ( nByteOfs < nHead ) ) ) {
		// partial first dword
		uint8_t const* pPartial = ( uint8_t const* )m_pData;
		if( m_pData ) {
		  m_nInBufWord = *( pPartial++ );
		  if( nHead > 1 )
			 m_nInBufWord |= ( *pPartial++ ) << 8;
		  if( nHead > 2 )
			 m_nInBufWord |= ( *pPartial++ ) << 16;
		}
		m_pDataIn = ( uint32_t const* )pPartial;
		m_nInBufWord >>= ( nPosition & 31 );
		m_nBitsAvail = ( nHead << 3 ) - ( nPosition & 31 );
	 } else {
		int nAdjPosition = nPosition - ( nHead << 3 );
		m_pDataIn = reinterpret_cast< uint32_t const* >(
		  reinterpret_cast< uint8_t const* >( m_pData ) + ( ( nAdjPosition / 32 ) << 2 ) + nHead );
		if( m_pData ) {
		  m_nBitsAvail = 32;
		  GrabNextDWord( );
		} else {
		  m_nInBufWord = 0;
		  m_nBitsAvail = 1;
		}
		m_nInBufWord >>= ( nAdjPosition & 31 );
		m_nBitsAvail = std::min( m_nBitsAvail, 32 - ( nAdjPosition & 31 ) ); // in case grabnextdword overflowed
	 }
	 return bSucc;
  }

  FORCEINLINE void GrabNextDWord( bool bOverFlowImmediately = false ) {
	 if( m_pDataIn == m_pBufferEnd ) {
		m_nBitsAvail = 1; // so that next read will run out of words
		m_nInBufWord = 0;
		m_pDataIn++; // so seek count increments like old
		if( bOverFlowImmediately )
		  m_bOverflow = true;
	 } else if( m_pDataIn > m_pBufferEnd ) {
		m_bOverflow = true;
		m_nInBufWord = 0;
	 } else {
		m_nInBufWord = LittleDWord( *( m_pDataIn++ ) );
	 }
  }
};

class bf_write {
public:
  unsigned char* m_pData;
  int m_nDataBytes;
  int m_nDataBits;
  int m_iCurBit;
  bool m_bOverflow;
  bool m_bAssertOnOverflow;
  const char* m_pDebugName;

  void StartWriting( void* pData, int nBytes, int iStartBit = 0, int nBits = -1 ) {
	 // Make sure it's dword aligned and padded.
	 // The writing code will overrun the end of the buffer if it isn't dword aligned, so truncate to force alignment
	 nBytes &= ~3;

	 m_pData = ( unsigned char* )pData;
	 m_nDataBytes = nBytes;

	 if( nBits == -1 ) {
		m_nDataBits = nBytes << 3;
	 } else {
		m_nDataBits = nBits;
	 }

	 m_iCurBit = iStartBit;
	 m_bOverflow = false;
  }

  bf_write( ) {
	 m_pData = NULL;
	 m_nDataBytes = 0;
	 m_nDataBits = -1; // set to -1 so we generate overflow on any operation
	 m_iCurBit = 0;
	 m_bOverflow = false;
	 m_bAssertOnOverflow = true;
	 m_pDebugName = NULL;
  }

  // nMaxBits can be used as the number of bits in the buffer.
  // It must be <= nBytes*8. If you leave it at -1, then it's set to nBytes * 8.
  bf_write( void* pData, int nBytes, int nBits = -1 ) {
	 m_bAssertOnOverflow = true;
	 m_pDebugName = NULL;
	 StartWriting( pData, nBytes, 0, nBits );
  }

  bf_write( const char* pDebugName, void* pData, int nBytes, int nBits = -1 ) {
	 m_bAssertOnOverflow = true;
	 m_pDebugName = pDebugName;
	 StartWriting( pData, nBytes, 0, nBits );
  }
};

class CLC_Move {
private:
  char __PAD0[0x8]; // 0x0 two vtables
public:
  int m_nBackupCommands; // 0x8
  int m_nNewCommands;    // 0xC
  void* m_data;   // 0x10 std::string
  int _cached_size_;
  uint32_t _has_bits_[( 3 + 31 ) / 32];
};                       // size: 0x50

template < typename T >
class CNetMessagePB : public INetMessage, public T {};
using CCLCMsg_Move_t = CNetMessagePB< CLC_Move >;
